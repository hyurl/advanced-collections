{"version":3,"sources":["webpack://AdvancedCollections/webpack/universalModuleDefinition","webpack://AdvancedCollections/webpack/bootstrap","webpack://AdvancedCollections/./index.js","webpack://AdvancedCollections/./lib/base-map.js","webpack://AdvancedCollections/./lib/bidirectional-map.js","webpack://AdvancedCollections/./lib/sorted-map.js","webpack://AdvancedCollections/./lib/sorted-set.js","webpack://AdvancedCollections/./lib/utils.js","webpack://AdvancedCollections/./node_modules/literal-toolkit/index.js","webpack://AdvancedCollections/./node_modules/literal-toolkit/lib/comment.js","webpack://AdvancedCollections/./node_modules/literal-toolkit/lib/keyword.js","webpack://AdvancedCollections/./node_modules/literal-toolkit/lib/number.js","webpack://AdvancedCollections/./node_modules/literal-toolkit/lib/regexp.js","webpack://AdvancedCollections/./node_modules/literal-toolkit/lib/string.js","webpack://AdvancedCollections/./node_modules/literal-toolkit/lib/util.js","webpack://AdvancedCollections/./node_modules/safe-string-literal/index.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;AClFa;AACb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,mBAAO,CAAC,mCAAa;AAChC,CAAC;AACD,IAAI,mBAAO,CAAC,2DAAyB;AACrC,IAAI,mBAAO,CAAC,6CAAkB;AAC9B,IAAI,mBAAO,CAAC,6CAAkB;AAC9B,E;;;;;;;;;;;;ACfa;AACb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,+BAAS;;AAErB;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe,qBAAqB;AACpC;AACA,oCAAoC;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,eAAe,OAAO;AACtB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,uBAAuB,uBAAuB;AAC9C;AACA;AACA;;AAEA;AACA,eAAe,yCAAyC;AACxD,eAAe,IAAI;AACnB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0B;;;;;;;;;;;;AClGa;AACb,8CAA8C,cAAc;;AAE5D,OAAO,yCAAyC,GAAG,mBAAO,CAAC,+BAAS;AACpE,OAAO,UAAU,GAAG,mBAAO,CAAC,qCAAY;;AAExC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAqC,gBAAgB;AACrD,SAAS;AACT;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sB;;;;;;;;;;;;AC1Da;AACb,8CAA8C,cAAc;;AAE5D,OAAO,gDAAgD,GAAG,mBAAO,CAAC,+BAAS;AAC3E,OAAO,UAAU,GAAG,mBAAO,CAAC,qCAAY;;AAExC;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe,qBAAqB;AACpC,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB,aAAa;AACtC;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8B;;;;;;;;;;;;AC7Da;AACb,8CAA8C,cAAc;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,GAAG,mBAAO,CAAC,+BAAS;;AAErB;AACA,aAAa;AACb;AACA;AACA;AACA,eAAe,cAAc;AAC7B,eAAe,+BAA+B;AAC9C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,aAAa;AACb;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,8B;;;;;;;;;;;;ACrGa;AACb,8CAA8C,cAAc;;AAE5D,gBAAgB,mBAAO,CAAC,gEAAiB;;AAEzC;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;;AAEL;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,oDAAoD,WAAW;;AAE/D;AACA;;AAEA;AACA,uBAAuB,cAAc;;AAErC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA;AACA,0BAA0B,eAAe;AACzC;AACA;;AAEA;AACA,aAAa;AACb;AACA;AACA,2BAA2B,gBAAgB;AAC3C;;AAEA;AACA,WAAW,MAAM;AACjB,aAAa,OAAO;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;;;;;;;AC/Ja;AACb,8CAA8C,cAAc;;AAE5D,iBAAiB,mBAAO,CAAC,kEAAc;AACvC,iBAAiB,mBAAO,CAAC,kEAAc;AACvC,kBAAkB,mBAAO,CAAC,oEAAe;AACzC,iBAAiB,mBAAO,CAAC,kEAAc;AACvC,kBAAkB,mBAAO,CAAC,oEAAe,E;;;;;;;;;;;;ACP5B;AACb,8CAA8C,cAAc;;AAE5D;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,cAAc,4F;AACd;AACA;AACA,iBAAiB;AACjB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,WAAW,oBAAoB;AAC/B,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA,uBAAuB,kBAAkB;AACzC;;AAEA;AACA;AACA,aAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,E;;;;;;;;;;;;AC/Ga;AACb,8CAA8C,cAAc;;AAE5D,yDAAyD,IAAI;;AAE7D;AACA;AACA,WAAW,OAAO;AAClB,cAAc,+F;AACd;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,qCAAqC;AAChD;AACA;AACA;AACA,E;;;;;;;;;;;;ACxDa;AACb,8CAA8C,cAAc;;AAE5D,kBAAkB,mBAAO,CAAC,0DAAQ;;AAElC;AACA,yBAAyB,KAAK;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB,cAAc,yF;AACd;AACA;AACA;AACA;AACA,iBAAiB;;AAEjB,mBAAmB,gBAAgB;AACnC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,aAAa,0BAA0B;AACvC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,4DAA4D;AACzE;AACA,oCAAoC,oBAAoB;AACxD;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,oBAAoB;AACjC;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA;AACA;AACA,aAAa,qBAAqB;AAClC;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB;AACA;AACA,aAAa,yBAAyB;AACtC;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA,aAAa;AACb;AACA,wDAAwD;AACxD;AACA,qBAAqB,+CAA+C;AACpE;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qCAAqC;AACrC;AACA,aAAa,+BAA+B;AAC5C;AACA,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,QAAQ;AACnB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;;AAEA;AACA,WAAW,gBAAgB;AAC3B,WAAW,gBAAgB;AAC3B;AACA;AACA;;AAEA,iBAAiB,qCAAqC;AACtD;;AAEA;AACA,E;;;;;;;;;;;;AC9Oa;AACb,8CAA8C,cAAc;;AAE5D,kBAAkB,mBAAO,CAAC,0DAAQ;;AAElC;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB,aAAa,O;AACb;AACA;AACA;;AAEA,qCAAqC,SAAS;AAC9C;AACA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,WAAW,OAAO;AAClB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS,YAAY;AACrB;;AAEA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA,C;;;;;;;;;;;;ACjGa;AACb,8CAA8C,cAAc;;AAE5D,kBAAkB,mBAAO,CAAC,0DAAQ;AAClC,8BAA8B,mBAAO,CAAC,wEAAqB;AAC3D,kCAAkC,mBAAO,CAAC,wEAAqB;;AAE/D;AACA;AACA;;AAEA;AACA,yBAAyB,KAAK;;AAE9B;AACA,WAAW,OAAO;AAClB,cAAc;AACd;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA,wBAAwB;AACxB,aAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,cAAc,0F;AACd;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT,0CAA0C,KAAK;AAC/C;AACA;AACA,iBAAiB;AACjB;AACA,iBAAiB;AACjB,gCAAgC;AAChC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,SAAS;;AAET;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW,OAAO;AAClB,WAAW,iBAAiB;AAC5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,C;;;;;;;;;;;AC5HA,yBAAyB,IAAI;;AAE7B;AACA;AACA,WAAW,OAAO;AAClB,YAAY,kCAAkC;AAC9C;AACA;AACA;AACA;AACA;AACA,C;;;;;;;;;;;;ACXa;AACb,8CAA8C,cAAc;;AAE5D;AACA,WAAW,OAAO;AAClB,WAAW,gBAAgB;AAC3B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,WAAW,OAAO;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA,4B","file":"advanced-collections.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"AdvancedCollections\"] = factory();\n\telse\n\t\troot[\"AdvancedCollections\"] = factory();\n})(this, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./index.js\");\n","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nif (!Array.prototype.includes) {\r\n    Array.prototype.includes = function includes(value, fromIndex = 0) {\r\n        return this.indexOf(value, fromIndex) !== -1;\r\n    }\r\n}\r\n\r\nmodule.exports = Object.assign({\r\n    utils: require(\"./lib/utils\")\r\n},\r\n    require(\"./lib/bidirectional-map\"),\r\n    require(\"./lib/sorted-map\"),\r\n    require(\"./lib/sorted-set\")\r\n);","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nconst {\r\n    keys,\r\n    values,\r\n    throwNotEntryError,\r\n    throwNotIterableError,\r\n    inherit,\r\n    fixToStringTag\r\n} = require(\"./utils\");\r\n\r\n/**\r\n * @abstract\r\n * @extends {Map}\r\n */\r\nclass BaseMap {\r\n    /**\r\n     * @param {Iterable<[any, any]>} iterable \r\n     */\r\n    constructor(iterable, props = {}) {\r\n        this[keys] = [];\r\n        this[values] = [];\r\n\r\n        Object.assign(this, props);\r\n\r\n        if (iterable !== undefined && iterable !== null) {\r\n            if (typeof iterable[Symbol.iterator] === \"function\") {\r\n                for (let item of iterable) {\r\n                    if (typeof item !== \"object\" || !(\"length\" in item)) {\r\n                        throwNotEntryError(item);\r\n                    } else {\r\n                        this.set(item[0], item[1]);\r\n                    }\r\n                }\r\n            } else {\r\n                throwNotIterableError(iterable);\r\n            }\r\n        }\r\n    }\r\n\r\n    get(key) {\r\n        let i = this[keys].indexOf(key);\r\n        return i === -1 ? void 0 : this[values][i];\r\n    }\r\n\r\n    has(key) {\r\n        return this[keys].includes(key);\r\n    }\r\n\r\n    /**\r\n     * @param {number} index \r\n     */\r\n    removeByIndex(index) {\r\n        if (index >= 0) {\r\n            this[keys].splice(index, 1);\r\n            this[values].splice(index, 1);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    delete(key) {\r\n        return this.removeByIndex(this[keys].indexOf(key));\r\n    }\r\n\r\n    clear() {\r\n        // Fast clear, reset the keys and values.\r\n        this[keys] = [];\r\n        this[values] = [];\r\n    }\r\n\r\n    *keys() {\r\n        for (let key of this[keys]) {\r\n            yield key;\r\n        }\r\n    }\r\n\r\n    *entries() {\r\n        for (let i = 0; i < this[keys].length; i++) {\r\n            yield [this[keys][i], this[values][i]];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {(value: any, key: any, map: Map) => void} callback \r\n     * @param {any} thisArg \r\n     */\r\n    forEach(callback, thisArg) {\r\n        for (let [key, value] of this.entries()) {\r\n            callback.call(thisArg, value, key, this);\r\n        }\r\n    }\r\n}\r\n\r\ninherit(BaseMap, Map);\r\nfixToStringTag(BaseMap);\r\nexports.BaseMap = BaseMap;","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nconst { keys, values, labelize, fixToStringTag } = require(\"./utils\");\r\nconst { BaseMap } = require(\"./base-map\");\r\n\r\nclass BiMap extends BaseMap {\r\n    constructor(iterable) {\r\n        super(iterable);\r\n    }\r\n\r\n    getKey(value) {\r\n        let i = this[values].indexOf(value);\r\n        return i === -1 ? void 0 : this[keys][i];\r\n    }\r\n\r\n    hasValue(value) {\r\n        return this[values].includes(value);\r\n    }\r\n\r\n    deleteValue(value) {\r\n        return this.removeByIndex(this[values].indexOf(value));\r\n    }\r\n\r\n    set(key, value) {\r\n        let i = this[values].indexOf(value);\r\n\r\n        if (i !== -1 && this[keys][i] !== key) {\r\n            // Values must be unique in order to search inversely.\r\n            throw new Error(`value ${labelize(value)} is duplicated`);\r\n        } else if (i === -1) {\r\n            let j = this[keys].indexOf(key);\r\n\r\n            if (j === -1) {\r\n                this[keys].push(key);\r\n                this[values].push(value);\r\n            } else {\r\n                this[values][j] = value;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    inverse() {\r\n        // Fast inverse, create a new instance without calling the constructor,\r\n        // and assign keys and values of the current instance to the new \r\n        // instance as its values and keys directly.\r\n        let map = Object.create(BiMap.prototype);\r\n\r\n        map[keys] = Array.from(this[values]);\r\n        map[values] = Array.from(this[keys]);\r\n\r\n        return map;\r\n    }\r\n}\r\n\r\nfixToStringTag(BiMap);\r\nexports.BiMap = BiMap;","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nconst { keys, values, findInsertIndex, fixToStringTag } = require(\"./utils\");\r\nconst { BaseMap } = require(\"./base-map\");\r\n\r\n/**\r\n * @extends {Map}\r\n */\r\nclass SortedMap extends BaseMap {\r\n    /**\r\n     * @param {Iterable<[any, any]>} iterable \r\n     * @param {(a: any, b: any) => -1 | 0 | 1} comparator\r\n     */\r\n    constructor(iterable, comparator = (a, b) => String(a) - String(b)) {\r\n        if (typeof iterable === \"function\") {\r\n            comparator = iterable;\r\n            iterable = [];\r\n        }\r\n\r\n        super(iterable, { comparator });\r\n    }\r\n\r\n    set(key, value) {\r\n        let i = this[keys].indexOf(key);\r\n\r\n        if (i !== -1) {\r\n            this[values][i] = value;\r\n        } else {\r\n            let index = findInsertIndex(key, this[keys], this.comparator);\r\n\r\n            if (index === -1) {\r\n                this[keys].unshift(key);\r\n                this[values].unshift(value);\r\n            } else if (index === Infinity) {\r\n                this[keys].push(key);\r\n                this[values].push(value);\r\n            } else {\r\n                this[keys].splice(index, 0, key);\r\n                this[values].splice(index, 0, value);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    reverse() {\r\n        // Fast reverse, create a new instance without calling the constructor,\r\n        // and assign the reversed values and comparator of the current instance\r\n        // to the new instance directly.\r\n        let map = Object.create(SortedMap.prototype);\r\n\r\n        map[keys] = Array.from(this[keys]).reverse();\r\n        map[values] = Array.from(this[values]).reverse();\r\n        map.comparator = (a, b) => -this.comparator(a, b);\r\n\r\n        return map;\r\n    }\r\n}\r\n\r\nfixToStringTag(SortedMap);\r\nexports.SortedMap = SortedMap;","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nconst {\r\n    values,\r\n    throwNotIterableError,\r\n    findInsertIndex,\r\n    inherit,\r\n    fixToStringTag\r\n} = require(\"./utils\");\r\n\r\n/**\r\n * @extends {Set}\r\n */\r\nclass SortedSet {\r\n    /**\r\n     * @param {Iterable<any>} iterable \r\n     * @param {(a: any, b: any) => -1 | 0 | 1} comparator\r\n     */\r\n    constructor(iterable, comparator = (a, b) => String(a) - String(b)) {\r\n        if (typeof iterable === \"function\") {\r\n            comparator = iterable;\r\n            iterable = [];\r\n        }\r\n\r\n        this[values] = [];\r\n        this.comparator = comparator;\r\n\r\n        if (iterable !== undefined && iterable !== null) {\r\n            if (typeof iterable[Symbol.iterator] === \"function\") {\r\n                for (let item of iterable) {\r\n                    this.add(item);\r\n                }\r\n            } else {\r\n                throwNotIterableError(iterable);\r\n            }\r\n        }\r\n    }\r\n\r\n    add(value) {\r\n        if (!this.has(value)) {\r\n            let index = findInsertIndex(value, this[values], this.comparator);\r\n\r\n            if (index === -1) {\r\n                this[values].unshift(value);\r\n            } else if (index === Infinity) {\r\n                this[values].push(value);\r\n            } else {\r\n                this[values].splice(index, 0, value);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    }\r\n\r\n    has(value) {\r\n        return this[values].includes(value);\r\n    }\r\n\r\n    delete(value) {\r\n        let i = this[values].indexOf(value);\r\n\r\n        if (i !== -1) {\r\n            this[values].splice(i, 1);\r\n            return true;\r\n        } else {\r\n            return false;\r\n        }\r\n    }\r\n\r\n    clear() {\r\n        this[values] = [];\r\n    }\r\n\r\n    reverse() {\r\n        // Fast reverse, create a new instance without calling the constructor,\r\n        // and assign the reversed values and comparator of the current instance\r\n        // to the new instance directly.\r\n        let set = Object.create(SortedSet.prototype);\r\n\r\n        set[values] = Array.from(this[values]).reverse();\r\n        set.comparator = (a, b) => -this.comparator(a, b);\r\n\r\n        return set;\r\n    }\r\n\r\n    *entries() {\r\n        for (let item of this[values]) {\r\n            yield [item, item];\r\n        }\r\n    }\r\n\r\n    forEach(callback, thisArg) {\r\n        for (let [key, value] of this.entries()) {\r\n            callback.call(thisArg, value, key, this);\r\n        }\r\n    }\r\n}\r\n\r\ninherit(SortedSet, Set);\r\nfixToStringTag(SortedSet);\r\nexports.SortedSet = SortedSet;","\"use strict\";\r\nObject.defineProperty(exports, \"__esModule\", { value: true });\r\n\r\nconst toolkit = require(\"literal-toolkit\");\r\n\r\n/**\r\n * @param {Function} ctor \r\n * @param {Function} base \r\n */\r\nfunction inherit(ctor, base) {\r\n    let isSet = base === Set || base.prototype instanceof Set;\r\n\r\n    Object.setPrototypeOf(ctor, base);\r\n    Object.setPrototypeOf(ctor.prototype, base.prototype);\r\n    Object.defineProperties(ctor.prototype, {\r\n        size: {\r\n            get() {\r\n                return this[module.exports.values].length;\r\n            }\r\n        },\r\n        values: {\r\n            value: function* values() {\r\n                for (let value of this[module.exports.values]) {\r\n                    yield value;\r\n                }\r\n            }\r\n        }\r\n    });\r\n    Object.defineProperty(ctor.prototype, Symbol.iterator, {\r\n        value: isSet ? ctor.prototype.values : ctor.prototype.entries\r\n    });\r\n\r\n    if (isSet) {\r\n        Object.defineProperty(ctor.prototype, \"keys\", {\r\n            value: ctor.prototype.values\r\n        });\r\n    }\r\n\r\n    return ctor;\r\n}\r\n\r\nfunction labelize(value) {\r\n    if (value === null) {\r\n        return \"null\";\r\n    } else if (value instanceof RegExp) {\r\n        return toolkit.regexp.toLiteral(value);\r\n    }\r\n\r\n    let type = typeof value;\r\n\r\n    switch (type) {\r\n        case \"string\":\r\n            return toolkit.string.toLiteral(value, \"'\");\r\n\r\n        case \"number\":\r\n        case \"bigint\":\r\n            return toolkit.number.toLiteral(value);\r\n\r\n        case \"function\":\r\n            return \"[Function\" + (value.name ? `: ${value.name}` : \"\") + \"]\";\r\n\r\n        case \"object\":\r\n            return \"[Object]\";\r\n\r\n        case \"symbol\":\r\n            return `[${String(value)}]`;\r\n\r\n        // undefined, boolean\r\n        default:\r\n            return String(value);\r\n    }\r\n}\r\n\r\nfunction fixToStringTag(ctor) {\r\n    Object.defineProperty(ctor.prototype, Symbol.toStringTag, {\r\n        value: ctor.name\r\n    });\r\n\r\n    return ctor;\r\n}\r\n\r\n/**\r\n * @returns {never}\r\n */\r\nfunction throwNotEntryError(item) {\r\n    throw new TypeError(\r\n        `Iterator value ${labelize(item)} is not an entry object`\r\n    );\r\n}\r\n\r\n/**\r\n * @returns {never}\r\n */\r\nfunction throwNotIterableError(input) {\r\n    throw new TypeError(`${labelize(input)} is not iterable`);\r\n}\r\n\r\n/**\r\n * @param {any[]} container\r\n * @returns {number} -1: unshift, Infinity: push, others: split\r\n */\r\nfunction findInsertIndex(item, container, comparator) {\r\n    let size = container.length;\r\n\r\n    if (size === 0) {\r\n        // If the container is empty, should push the new item into the end of\r\n        // the container directly.\r\n        return Infinity;\r\n    } else {\r\n        let res = comparator(item, container[0]);\r\n\r\n        if (res < 0) {\r\n            // If new item is smaller than the the first item in the container,\r\n            // should put/unshift the new item into the head of the container.\r\n            return -1;\r\n        } else if (\r\n            size === 1 ||\r\n            (res = comparator(item, container[size - 1])) >= 0\r\n        ) {\r\n            // If there is only one item in the container and the new item is\r\n            // larger than it, or the new item is larger than the last item in\r\n            // the container, should push the new item into the end of the \r\n            // container.\r\n            return Infinity;\r\n        } else {\r\n            let index = size - 1;\r\n            let dec = 0;\r\n            let res = 0;\r\n\r\n            // Finding the index via dichotomy.\r\n            while (size = size / 2) {\r\n                dec = Math.floor(size);\r\n                size = Math.ceil(size);\r\n                index -= dec;\r\n                res = comparator(item, container[index]);\r\n\r\n                if (size === 1) {\r\n                    return res === -1 ? index : index + 1;\r\n\r\n                    // When a specific index is returned, the caller should \r\n                    // insert the new item to the index of the container via the\r\n                    // splice method.\r\n                } else if (res >= 0) {\r\n                    index += dec;\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nmodule.exports = {\r\n    keys: Symbol(\"keys\"),\r\n    values: Symbol(\"values\"),\r\n    inherit,\r\n    labelize,\r\n    fixToStringTag,\r\n    throwNotEntryError,\r\n    throwNotIterableError,\r\n    findInsertIndex\r\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nexports.string = require(\"./lib/string\");\nexports.number = require(\"./lib/number\");\nexports.keyword = require(\"./lib/keyword\");\nexports.regexp = require(\"./lib/regexp\");\nexports.comment = require(\"./lib/comment\");","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar INLINE_COMMENT = /^\\s*\\/\\/.*\\n*?/;\nvar BLOCK_COMMENT = /^\\s*\\/\\*[\\s\\S]*?\\*\\//;\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: string, type: \"//\" | \"/*\" | \"/**\" }} \n */\nfunction parseToken(str) {\n    var token = { source: \"\", offset: 0, length: 0, value: \"\", type: \"\" };\n    var match = INLINE_COMMENT.exec(str) || BLOCK_COMMENT.exec(str);\n\n    if (match) {\n        token.offset = match[0].indexOf(\"/\");\n        token.length = match[0].length - token.offset;\n        token.source = token.value = match[0].slice(token.offset);\n\n        if (token.value[1] === \"/\") {\n            token.type = \"//\";\n        } else if (token.value.slice(1, 3) === \"**\") {\n            token.type = \"/**\"\n        } else {\n            token.type = \"/*\";\n        }\n\n        return token;\n    } else {\n        return null;\n    }\n}\n\n/**\n * \n * @param {string} str \n * @param {boolean} strip Strip meaningless characters.\n */\nexports.parse = function parse(str, strip) {\n    var token = parseToken(str);\n\n    if (!token) return;\n\n    if (!strip) {\n        return token.value;\n    } else if (token.type === \"//\") {\n        return token.value.replace(/^\\/\\/\\s*/, \"\");\n    } else {\n        var lines = token.value.replace(/\\s*\\*\\/$/, \"\").split(\"\\n\");\n        var value = lines[0].replace(/^\\/\\*\\s*/, \"\");\n        var isNewLine = false;\n\n        for (var i = 1; i < lines.length; i++) {\n            if (/^[\\s\\*]*$/.test(lines[i])) {\n                if (!isNewLine) {\n                    value += \"\\n\";\n                    isNewLine = true;\n                }\n            } else {\n                value += (isNewLine ? \"\" : \" \") + lines[i].replace(/^[\\s\\*]*/, \"\");\n                isNewLine = false;\n            }\n        }\n\n        return value;\n    }\n};\n\n/**\n * @param {string} str\n * @param {\"//\" | \"/*\" | \"/**\"} type\n * @param {string} indent Indent all rest lines of the comment with the given spaces.\n */\nexports.toLiteral = function toLiteral(str, type, indent) {\n    type = type || \"//\";\n    indent = indent || \"\";\n\n    var hasMultiLine = str.indexOf(\"\\n\") >= 0;\n\n    if (!hasMultiLine) {\n        if (type === \"//\") {\n            return \"// \" + str;\n        } else {\n            return type + \" \" + str + \" */\";\n        }\n    } else {\n        var lines = str.split(\"\\n\");\n\n        if (type === \"//\") {\n            lines[0] = \"// \" + lines[0];\n        } else {\n            lines.unshift(type);\n        }\n\n        for (var i = 1; i < lines.length; i++) {\n            lines[i] = lines[i].replace(/^\\s*/, \"\");\n\n            if (type == \"//\") {\n                lines[i] = indent + \"// \" + lines[i];\n            } else {\n                lines[i] = indent + \" * \" + lines[i];\n            }\n        }\n\n        if (type !== \"//\") {\n            lines.push(indent + \" */\");\n        }\n\n        return lines.join(\"\\n\");\n    }\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar KEYWORDS = /^\\s*(true|false|null|NaN|Infinity)(\\s*[,;)\\]}]|\\s*$)/;\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: true | false | null | NaN | Infinity }} \n */\nfunction parseToken(str) {\n    var match = KEYWORDS.exec(str);\n\n    if (match) {\n        var value;\n\n        switch (match[1]) {\n            case \"true\":\n                value = true;\n                break;\n            case \"false\":\n                value = false;\n                break;\n            case \"NaN\":\n            case \"Infinity\":\n                value = Number(match[1]);\n                break;\n            default:\n                value = null;\n                break;\n        }\n\n        return {\n            source: match[1],\n            offset: str.indexOf(match[1]),\n            length: match[1].length,\n            value: value\n        };\n    } else {\n        return null;\n    }\n}\n\n/**\n * @param {string} str \n */\nexports.parse = function parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n};\n\n/**\n * @param {true | false | null | NaN | Infinity} keyword\n */\nexports.toLiteral = function toLiteral(keyword) {\n    return String(keyword);\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\n\nvar NUM_SEQUENCE = \"0123456789abcdefinox-+.\";\nvar BOUNDARIES = /^\\s*[,;:)\\]}\\/]|^\\s*$/;\nvar OTCAL_MARK = /0o/i;\n\nexports.BIN = 2;\nexports.OCT = 8;\nexports.DEC = 10;\nexports.HEX = 16;\n\nfunction isHead(matches, char) {\n    char = char || \"\";\n    return matches === char || matches === \"+\" + char || matches === \"-\" + char;\n}\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @param {boolean} allowTrailings\n * @returns {{ source: string, offset: number, length: number, value: number, radix: 2 | 8 | 10 | 16 }} \n */\nfunction parseToken(str) {\n    var allowTrailings = arguments[1] || false;\n    var matches = \"\";\n    var token = { source: \"\", offset: -1, length: 0, value: NaN, radix: 0 };\n\n    for (var i = 0; i < str.length; ++i) {\n        var char = str[i];\n\n        if (char != false || char === \"0\") {\n            if (token.offset === -1) {\n                token.offset = i;\n            }\n\n            var _char = char.toLowerCase();\n            var pos = NUM_SEQUENCE.indexOf(_char);\n\n            if (pos === -1) {\n                break;\n            } else if (_char === \"e\") { // exponential\n                if (token.radix === 16 || (\n                    token.radix === 10 && matches.indexOf(char) === -1)\n                ) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (_char === \"b\" || _char === \"o\" || _char === \"x\") { // non-decimal\n                if (isHead(matches, \"0\")) {\n                    token.radix = ({ b: 2, o: 8, x: 16 })[_char];\n                    matches += char;\n                } else if (_char === \"b\" && token.radix === 16) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (pos < 8) { // octal\n                if (isHead(matches)) {\n                    if (char === \"0\") {\n                        token.radix = 8;\n                    } else {\n                        token.radix = 10;\n                    }\n                }\n                matches += char;\n            } else if (pos < 10) { // decimal\n                if (token.radix === 2 || token.radix === 8) {\n                    token.radix = 10;\n                }\n                matches += char;\n            } else if (pos < 16) { // hexdecimal\n                if (token.radix === 16) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (char === \"n\") { // bigint\n                if (matches[0] === \"+\"\n                    || (\n                        token.radix === 8 && OTCAL_MARK.test(matches) === false\n                    ) || (\n                        token.radix === 10 && matches.indexOf(\".\") >= 0\n                    )) {\n                    // bigint doesn't support plus sign, non-standard octal \n                    // number and float number.\n                    return null;\n                } else {\n                    matches += char;\n                    break;\n                }\n            } else if (char === \".\") { // float\n                if (isHead(matches)) {\n                    token.radix = 10;\n                    matches += char;\n                } else if (token.radix === 10 && matches.indexOf(\".\") === -1) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else if (isHead(char)) { // - or +\n                if (matches === \"\" || ( // signed number\n                    str[i - 1] === \"e\" || str[i - 1] === \"E\" // scientific notation\n                )) {\n                    matches += char;\n                } else {\n                    break;\n                }\n            } else {\n                if (isHead(matches)) {\n                    if (str.slice(i, i + 3) === \"NaN\") { // NaN\n                        matches += \"NaN\";\n                    } else if (str.slice(i, i + 8) === \"Infinity\") { // Infinity\n                        matches += \"Infinity\";\n                    } else {\n                        return null;\n                    }\n                }\n                break;\n            }\n        }\n    }\n\n    token.source = matches;\n    token.length = matches.length;\n    token.offset = token.offset === -1 ? 0 : token.offset;\n    token.radix = token.radix || 10;\n\n    if (matches) {\n        if (token.radix === 8 && OTCAL_MARK.test(matches) === false) {\n            token.value = parseInt(matches, 8);\n        } else {\n            var isBigInt = matches[matches.length - 1] === \"n\";\n\n            if (isBigInt && typeof BigInt !== \"function\") {\n                // If the environment doesn't support BigInt, don't parse.\n                return null;\n            }\n\n            var parse = isBigInt ? BigInt : Number;\n            var source = isBigInt ? matches.slice(0, -1) : matches;\n\n            if (matches[0] === \"-\") { // minus\n                token.value = -parse(source.slice(1));\n            } else if (matches[0] === \"+\") { // plus\n                token.value = parse(source.slice(1));\n            } else {\n                token.value = parse(source);\n            }\n        }\n    }\n\n    if (!allowTrailings && !strictMatch(str, token, BOUNDARIES)) {\n        return null;\n    } else {\n        return token;\n    }\n}\n\nexports.parse = parse;\n/**\n * @param {string} str \n * @param {boolean} strict \n */\nfunction parse(str, strict) {\n    var token = parseToken(str, !strict);\n    return token ? token.value : undefined;\n}\n\nfunction isRadix(str, radix) {\n    var token = parseToken(str);\n    return token ? token.radix == radix : false;\n}\n\n/**\n * @param {string} str \n */\nexports.isBin = function isBin(str) {\n    return isRadix(str, 2);\n};\n\n/**\n * @param {string} str \n */\nexports.isOct = function isOct(str) {\n    return isRadix(str, 8);\n};\n\n/**\n * @param {string} str \n */\nexports.isDec = function isDec(str) {\n    return isRadix(str, 10);\n};\n\n/**\n * @param {string} str \n */\nexports.isHex = function isHex(str) {\n    return isRadix(str, 16);\n};\n\n/**\n * @param {string} str \n */\nexports.isNaN = function isNaN(str) {\n    var value = parse(str, true);\n    return value === undefined || Number.isNaN(value);\n};\n\n/**\n * @param {string} str \n */\nexports.isFinite = function isFinite(str) {\n    return Number.isFinite(parse(str, true));\n};\n\n/**\n * @param {string} str\n */\nexports.isBigInt = function isBigInt(str) {\n    return typeof parse(str, true) === \"bigint\";\n};\n\n/**\n * @param {number | bigint} num\n * @param {2 | 8 | 10 | 16} radix\n */\nexports.toLiteral = function toLiteral(num, radix) {\n    radix = radix || 10;\n\n    let head = ({ 2: \"0b\", 8: \"0o\", 10: \"\", 16: \"0x\" })[radix];\n    let str = num.toString(radix) + (typeof num === \"bigint\" ? \"n\" : \"\");\n\n    return str[0] === \"-\" ? (\"-\" + head + str.slice(1)) : (head + str);\n};","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\n\nvar LEADING_SLASH = /^\\s*(\\/)/;\nvar EOL = /[\\n\\r]/;\nvar FLAGS = \"gimsuy\";\n\n/**\n * @param {string} str \n * @returns {{ offset: number, source: string }}\n */\nfunction getSlashedBlock(str) {\n    var matches = str.match(LEADING_SLASH);\n\n    if (matches) {\n        var offset = str.indexOf(matches[1]),\n            index = offset,\n            source = matches[1];\n\n        str = str.slice(offset + 1);\n\n        while (-1 !== (index = str.indexOf(matches[1]))) {\n            source += str.slice(0, index + 1);\n\n            if (source[source.length - 2] !== \"\\\\\") {\n                return { offset, source };\n            } else {\n                str = str.slice(index + 1);\n            }\n        }\n    }\n\n    return null;\n}\n\n/**\n * @param {string} str\n * @returns {string} \n */\nfunction getFlags(str) {\n    var flags = \"\";\n\n    for (let i = 0, len = str.length; i < len; ++i) {\n        if (FLAGS.indexOf(str[i]) >= 0 && flags.indexOf(str[i]) === -1) {\n            flags += str[i];\n        } else {\n            break;\n        }\n    }\n\n    return flags;\n}\n\nexports.parseToken = parseToken;\n/**\n * \n * @param {string} str \n * @returns {{ source: string, offset: number, length: number, value: RegExp }}\n */\nfunction parseToken(str) {\n    var block = getSlashedBlock(str);\n\n    if (block && block.source !== \"//\" && EOL.test(block.source) === false) {\n        try {\n            var flags = getFlags(str.slice(block.offset + block.source.length));\n            var value = new RegExp(block.source.slice(1, -1), flags);\n            var token = {\n                source: block.source + flags,\n                offset: block.offset,\n                length: block.source.length + flags.length,\n                value: value\n            };\n\n            if (strictMatch(str, token)) {\n                return token;\n            }\n        } catch (e) { }\n    }\n\n    return null;\n}\n\n/**\n * @param {string} str\n */\nexports.parse = function parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n};\n\n/**\n * @param {RegExp} re\n */\nexports.toLiteral = function toLiteral(re) {\n    return String(re);\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\nvar strictMatch = require(\"./util\").strictMatch;\nvar escape = exports.escape = require(\"safe-string-literal\").escape;\nvar unescape = exports.unescape = require(\"safe-string-literal\").unescape;\n\nexports.SINGLE_QUOTE = \"'\";\nexports.DOUBLE_QUOTE = '\"';\nexports.BACK_QUOTE = \"`\";\n\nvar LEADING_QUOTES = /^\\s*(\"|'|`)/;\nvar BOUNDARIES = /^\\s*[,;:)\\]}\\/]|^\\s*$/;\n\n/**\n * @param {string} str \n * @returns {{ quote: string, offset: number, source: string }}\n */\nfunction getQuotedBlock(str) {\n    var matches = str.match(LEADING_QUOTES);\n\n    if (matches) {\n        var quote = matches[1],\n            offset = str.indexOf(quote),\n            index = offset,\n            source = quote;\n\n        str = str.slice(offset + 1);\n\n        while (-1 !== (index = str.indexOf(quote))) {\n            source += str.slice(0, index + 1);\n\n            if (source[source.length - 2] !== \"\\\\\") {\n                return { quote, offset, source };\n            } else {\n                str = str.slice(index + 1);\n            }\n        }\n    }\n\n    return null;\n}\n\n/**\n * @param {string} str \n */\nfunction removeUnusedEscapes(str) {\n    var exludes = \"\\\\'\\\"`bfnrtux\";\n    return String(str).replace(/\\\\\\S/g, function (chars) {\n        if (!~exludes.indexOf(chars[1])) {\n            return chars[1];\n        } else {\n            return chars;\n        }\n    });\n}\n\nexports.parseToken = parseToken;\n/**\n * @param {string} str\n * @returns {{ source: string, offset: number, length: number, value: string, quote: \"'\" | \"\\\"\" | \"`\" }} \n */\nfunction parseToken(str) {\n    var block = getQuotedBlock(str);\n\n    if (block) {\n        var value;\n        var lines = block.source.slice(1, -1).split(\"\\n\");\n\n        if (lines.length === 1) {\n            value = unescape(removeUnusedEscapes(lines[0]));\n        } else {\n            for (var i = lines.length - 1; i--;) {\n                if (lines[i][lines[i].length - 1] === \"\\\\\") {\n                    lines[i] = lines[i].slice(0, -1);\n                } else if (block.quote === \"`\") {\n                    lines[i] += \"\\n\";\n                } else {\n                    return null; // invalid new line\n                }\n            }\n\n            value = unescape(removeUnusedEscapes(lines.join(\"\")));\n        }\n\n        var token = Object.assign(block, {\n            length: block.source.length,\n            value: value\n        });\n\n        if (strictMatch(str, token, BOUNDARIES)) {\n            return token;\n        }\n    }\n\n    return null;\n}\n\nexports.parse = parse;\n/**\n * @param {string} str \n */\nfunction parse(str) {\n    var token = parseToken(str);\n    return token ? token.value : undefined;\n}\n\nexports.toLiteral = toLiteral;\n/**\n * @param {string} str \n * @param {\"'\" | \"\\\"\" | \"`\"} quote \n */\nfunction toLiteral(str, quote) {\n    var exclues;\n    quote = quote || '\"';\n\n    if (quote === \"'\")\n        exclues = '\"`';\n    else if (quote === '\"')\n        exclues = \"'`\";\n    else if (quote === \"`\")\n        exclues = \"'\\\"\\n\";\n\n    return quote + escape(str, exclues) + quote;\n}","var BOUNDARIES = /^\\s*[,;)\\]}\\/]|^\\s*$/;\n\nexports.strictMatch = strictMatch;\n/**\n * @param {string} str \n * @param {{ offset: number, length: number }} token \n */\nfunction strictMatch(str, token) {\n    var boundaries = arguments[2] || BOUNDARIES;\n    var leftOver = str.slice(token.offset + token.length);\n    return !leftOver || boundaries.test(leftOver);\n}","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n\n/**\n * @param {string} str \n * @param {string|string[]} excludes \n */\nfunction escape(str, excludes) {\n    return String(str).replace(/[\"'`\\\\\\b\\f\\n\\r\\t\\u2028\\u2029]/g, function (char) {\n        if (excludes && excludes.indexOf(char) >= 0)\n            return char;\n\n        switch (char) {\n            case '\"':\n            case \"'\":\n            case '`':\n            case \"\\\\\":\n                return \"\\\\\" + char;\n            case \"\\b\":\n                return \"\\\\b\";\n            case \"\\f\":\n                return \"\\\\f\";\n            case \"\\n\":\n                return \"\\\\n\";\n            case \"\\r\":\n                return \"\\\\r\";\n            case \"\\t\":\n                return \"\\\\t\";\n            case \"\\u2028\":\n                return \"\\\\u2028\";\n            case \"\\u2029\":\n                return \"\\\\u2029\";\n        }\n    });\n}\n\n/**\n * @param {string} str \n */\nfunction unescape(str) {\n    return String(str).replace(/\\\\[\"'`\\\\bfnrt]|\\\\u2028|\\\\u2029/g, function (chars) {\n        switch (chars) {\n            case '\\\\\"':\n            case \"\\\\'\":\n            case \"\\\\`\":\n            case \"\\\\\\\\\":\n                return chars[1];\n            case \"\\\\b\":\n                return \"\\b\";\n            case \"\\\\f\":\n                return \"\\f\";\n            case \"\\\\n\":\n                return \"\\n\";\n            case \"\\\\r\":\n                return \"\\r\";\n            case \"\\\\t\":\n                return \"\\t\";\n            case \"\\\\u2028\":\n                return \"\\u2028\";\n            case \"\\\\u2029\":\n                return \"\\u2029\";\n        }\n    });\n}\n\nexports.escape = escape;\nexports.unescape = unescape;"],"sourceRoot":""}